
# Javascript

모든 브라우저의 표준 프로그래밍 언어.  
이름을 Java에서 차용해왔지만, 홍보 목적의 이유일 뿐 Java와 아무 상관이 없는 독자적인 언어이다. 

**명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.**

브라우저에도 자바스크립트 엔진이 내장되어 있다.  
엔진의 종류는 브라우저마다 다르다.

<br>

<엔진-브라우저>  
V8 – Chrome, Opera  
SpiderMonkey – Firefox  
ChakraCore - Microsoft Edge   
SquirrelFish - Safari  

<br>

모던 자바스크립트는 메모리나 CPU 같은 저수준 영역의 조작을 허용하지 않는 안전한 언어이다. 애초에 이러한 접근이 필요치 않은 브라우저를 대상으로 만든 언어이기 때문이다.

자바스크립트는 실행 환경에 따라 제약이 다르다. 

Node.js 환경 - 임의의 파일을 읽거나 쓰고, 네트워크 요청을 수행하는 함수를 지원  
브라우저 환경 - 웹페이지 조작, 클라이언트와 서버의 상호작용에 관한 모든 일 지원


<br>

브라우저는 보안을 위해 자바스크립트의 기능에 제약을 걸어놓았다. 

- 웹페이지 내 스크립트는 디스크에 저장된 임의의 파일을 읽거나 쓰고, 복사하거나 실행할 때 제약을 받는다. 운영체제가 지원하는 기능을 브라우저가 직접 쓰지 못하게 막았기 때문. 파일을 사용하려면 사용자가 파일을 끌어다 놓거나 input 같은 기능을 사용해야하고, 카메라나 마이크 같은 디바이스와 상호 작용하려면 사용자의 명시적인 허가가 있어야 한다.

- 브라우저 내 탭과 창은 대개 서로의 정보를 알 수 없다. 다만 자바스크립트를 사용해 한 창에서 다른 창을 열 때는 예외가 적용된다. 하지만 이 경우에도 도메인이나 프로토콜, 포트가 다르다면 페이지에 접근할 수 없습니다. (브라우저는 보안을 위해 동일 출처 정책을 지키기 때문)

<br>

근래에는 브라우저에서 실행 되기 전에 자바스크립트로 트랜스파일(transpile, 변환) 할 수 있는 새로운 언어들이 많이 등장했다.  
자바스크립트 이외의 언어로 작성한 코드를 실행할 때 자바스크립트로 자동 변환해준다.

- CoffeeScript : 자바스크립트를 위한 syntactic sugar. 짧은 문법을 도입하여 명료하고 이해하기 쉬운 코드를 작성할 수 있다. Ruby 개발자들이 많이 사용.
- TypeScript : 자료형의 명시화에 집중해 만든 언어. Microsoft가 개발하.
- Flow : TypeScript와는 다른 방식으로 자료형을 강제. Facebook이 개발.
- Dart : 모바일 앱과 같이 브라우저가 아닌 환경에서 동작하는 고유의 엔진을 가진 독자적 언어. Google이 개발.

<br>

## Prototype 기반 객체지향

자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 한다. 프로토타입 기반 프로그래밍은 클래스가 필요없는(class-free) 객체지향 프로그래밍 스타일로 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현할 수 있다.


Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다.


<br>

## this 동작 방식

자바스크립트의 this는 동적으로 결정된다. 정확히 말하면 런타임에 함수 호출 방식에 따라 결정된다. 또한 엄격모드냐 비엄격모드냐에 따라서도 차이가 있다. 

전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side 에서는 global 객체를 의미한다

전역에 선언된 함수, 콜백함수는 모두 전역객체를 this로 바인딩한다.  글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이기 때문이라고 생각하면 기억하기 쉽다. 하지만 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관계없이 this는 전역객체를 바인딩하는데, 설계 단계의 결함이라고 한다. 

내부함수의 this가 전역객체를 참조하는 것을 회피방법은 아래와 같다.

```
var value = 1;

var obj = {
  value: 100,
  foo: function() {
    var that = this;  // Workaround : this === obj

    console.log("foo's this: ",  this);  // obj
    console.log("foo's this.value: ",  this.value); // 100
    function bar() {
      console.log("bar's this: ",  this); // window
      console.log("bar's this.value: ", this.value); // 1

      console.log("bar's that: ",  that); // obj
      console.log("bar's that.value: ", that.value); // 100
    }
    bar();
  }
};

obj.foo();

```

함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.



## CallBack
보통 다른 함수의 인자로 사용되며 어떤 이벤트에 의해 호출되어지는 함수를 뜻한다.

자바스크립트에서는 콜백 함수를 사용하여 비동기 논블로킹 프로그래밍을 구현하고, 이를 통해 싱글 스레드 환경의 효율을 높인다. 쉽게 표현하자면 스레드가 멈추는 일이 없도록 한다는 뜻이다.

보통 아래와 같은 처리를 할 때 많이 활용한다.

1. 이벤트가 발생할 시점을 예측 불가능한 경우  
예를 들면 사용자 이벤트 처리가 있다. 브라우저 화면에서 사용자가 어떤 동작을 언제할 지는 예측이 불가능하다. 

2. 응답 시점을 예측 불가능한 경우
예를 들면 네트워크를 통해 서버에 요청을 보냈을 때, 응답이 언제 올지 알 수 없다. 이런 서버에 대한 응답처리 등도 비동기적으로 처리하는 것이 좋다.

3. 시간을 재거나 지연하는 일이 필요할 경우
예를 들면 3초 후 울리는 알람 등의 기능을 구현할 때 setTimeOut 함수 등을 사용하는 경우를 말한다. 

하지만 콜백이 꼬리에 꼬리를 물고 발생하는 경우 콜백 지옥이 발생한다.   
콜백 지옥(Callback Hell)은 함수의 매개변수로 넘겨지는 콜백 함수가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 말한다. 


## Promise

Promise 객체는 프로미스가 생성된 시점에는 알려지지 않았을수도 있는 값을 위한 대리자이다. 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 처리하기 위한 처리기를 연결할 수 있다. 프로미스를 사용하면 비동기 메소드에서 마치 동기 메소드처럼 값을 반환할 수 있다. 다만 최종 결과를 반환하는 것이 아니고, 미래의 어떤 시점에 결과를 제공하겠다는 약속을 제공한다.

Promise는 다음 중 하나의 상태를 가집니다.

대기(pending): 이행하지도, 거부하지도 않은 초기 상태.
이행(fulfilled): 연산이 성공적으로 완료됨.
거부(rejected): 연산이 실패함.

대기 중인 프로미스는 값과 함께 이행할 수도, 어떤 이유(오류)로 인해 거부될 수도 있습니다. 이행이나 거부될 때, 프로미스의 then 메서드에 의해 대기열(큐)에 추가된 처리기들이 호출됩니다. 이미 이행했거나 거부된 프로미스에 처리기를 연결해도 호출되므로, 비동기 연산과 처리기 연결 사이에 경합 조건은 없습니다.


# ECMAScript6

## let, const

ES6는 블록 레벨 스코프를 따르는 변수를 선언하기 위해 let 키워드를 제공한다. var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러가 발생한다

const는 상수를 선언할 때 사용한다. 선언과 동시에 초기화가 이루어져야하고, 재할당이 금지된다. 


## 클래스

ES6의 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순명료한 새로운 문법이다. 하지만 클래스 기반의 객체 지향으로 탈바꿈한 것이 아니다. 클래스도 함수이고, 기존 프로토타입 기반 패턴을 더 익숙한 문법으로 제공하는 것이라고할 수 있다. 다만, 클래스와 생성자 함수가 완전히 동일하게 동작하지는 않는다. 

클래스는 var 키워드로 선언한 변수처럼 호이스팅되지 않고 let, const 키워드로 선언한 변수처럼 호이스팅 된다. 

### constructor

constructor는 인스턴스를 생성하고 클래스 필드를 초기화하기 위한 메소드이다.

```
class Person {
  constructor(name) {
    // this는 클래스가 생성할 인스턴스를 가리킨다.
    // _name은 클래스 필드이다.
    this._name = name;
  }
}

const me = new Person('Lee');
console.log(me); // Person {_name: "Lee"}
```

## 화살표 함수

화살표 함수의 기본 문법

```
// 매개변수 지정 방법
    () => { ... } // 매개변수가 없을 경우
     x => { ... } // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.
(x, y) => { ... } // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.

// 함수 몸체 지정 방법
x => { return x * x }  // single line block
x => x * x             // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.

() => { return { a: 1 }; }
() => ({ a: 1 })  // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.

() => {           // multi line block.
  const x = 10;
  return x * x;
};
```

화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되며 언제나 상위 스코프의 this를 가리킨다.

화살표 함수로 메소드를 정의하는 것은 피해야 한다. 메소드로 정의한 화살표 함수의 this는 메소드를 소유한 객체(메소드를 호출한 객체)를 가리키지 않고 상위 컨택스트인 전역 객체 window를 가리킨다. 따라서 메소드로 화살표 함수를 사용하는 것은 적절하지 않다. 대신 메소드를 위한 단축 표기법인 ES6의 축약 메소드 표현을 사용하는 것이 좋다.

또한 콜백 함수를 화살표 함수로 정의하면 this가 상위 컨택스트인 전역 객체 window를 가리키기 때문에 콜백 함수 내부에서 this를 사용할 일이 있다면 function 키워드로 선언된 일반 함수를 사용해야한다. 

## Modules

모듈은 파일 단위로 분리되어 있으며 애플리케이션은 필요에 따라 명시적으로 모듈을 로드하여 재사용한다.

script 태그에 type="module" 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. ES6 모듈의 파일 확장자는 모듈임을 명확히 하기 위해 mjs를 사용하도록 권장한다.

```
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```

ES6 모듈 기능을 사용하지 않으면 분리된 자바스크립트 파일에 독자적인 스코프를 갖지 않고 하나의 전역을 공유한다. HTML에서 2개의 자바스크립트 파일을 로드하면 로드된 자바스크립트는 하나의 전역을 공유한다. ES6 모듈은 파일 자체의 스코프를 제공한다. 즉, ES6 모듈은 독자적인 모듈 스코프를 갖는다. 따라서, 모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

### export, import

모듈은 독자적인 모듈 스코프를 갖기 때문에 모듈 안에 선언한 모든 식별자는 기본적으로 해당 모듈 내부에서만 참조할 수 있다. 만약 모듈 안에 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할 수 있게 하고 싶다면 export 키워드를 사용한다. 선언된 변수, 함수, 클래스 모두 export할 수 있다.

모듈에서 export한 대상을 로드하려면 import 키워드를 사용하면 된다. 



## Rest Parameter

Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 항상 마지막 파라미터로 두어야한다.

```
function foo(...rest) {
  console.log(Array.isArray(rest)); // true
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);
```



# Babel

바벨은 자바스크립트 컴파일러이다.  
자바스크립트는 인터프리터 언어이지만, 브라우저마다 지원하는 자바스크립트 버전이 상이하기 때문에 최신 자바스크립트를 하위 버전으로 변경해서 호환할 수 있도록 해주는 자바스크립트 -> 자바스크립트 컴파일러가 필요하고 이 때 사용하는 것이 바벨 같은 도구이다. 


# nodejs

Node.js는 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(Runtime Environment)으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼이다. Node.js는 브라우저 외부 환경에서 자바스크립트 애플리케이션 개발에 사용되며 이에 필요한 모듈, 파일 시스템, HTTP 등 Built-in API를 제공한다.

Node.js는 Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 Request 처리 성능을 가지고 있다.

데이터베이스로부터 대량의 데이터를 취득하여 웹페이지에 표시할 때, 일반적으로 데이터베이스 처리에 대기시간(blocking)이 발생하기 때문에 웹페이지 표시가 지연되는 현상이 발생한다. Node.js의 모든 API는 비동기 방식으로 동작하여 Non-blocking I/O가 가능하고 단일 스레드 이벤트 루프 모델을 사용하여 보다 가벼운 환경에서도 높은 Request 처리 성능을 가지고 있다.

Node.js는 데이터를 실시간 처리하여 빈번한 I/O가 발생하는 SPA(Single Page Application)에 적합하다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.