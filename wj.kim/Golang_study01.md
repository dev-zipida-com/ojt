# GoLang
## 개요
 Go는 C언어 기반으로 C++와 Java, Python의 장점을 뽑아 개발되었습니다. Go는 객체지향 프로그래밍 (OOP Object Oriented Programming)을 지원하지만 클래스, 객체, 상속에 대한 개념이 없습니다. 상속의 지원 여부보다 객체 간의 상호작용을 중심으로 한 프로그래밍 언어입니다.   
 Go에서 쓰이는 키워드는 Java에 절반 수준인 25개밖에 되지 않습니다. 또한, Go는 컴파일 언어지만 컴파일러의 컴파일 속도가 매우 빠르기 때문에 인터프리터 언어처럼 쓸 수 있습니다. 컴파일 언어이기 때문에 인터프리터 언어보다는 빠르지 않지만 인터프리터 언어 이상의 성능을 감안했을 때 굉장히 큰 효율을 보여줍니다.

 ## Go 특징   
 Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 목표로 합니다.
 - 정적 탑입 : 자료형이 정해져있음
 - 강타입 : 자료형 변환(타입캐스팅)이 항상 명시되어야 함
 - 안정성 : 타입 안정성과 메모리 안정성
 - 병행성 : 스레드를 한 단계 더 추상화한 '고루틴' 이라는 개념 사용
 - 가비지 컬렉션 : 결과물이 go runtime에 저장되는데 go run time이 메모리 핸들링
 - 컴파일 언어 : 인터프리터 언어가 아니지만 근접한 수준의 빠른 컴파일
 - 포인터는 존재, 그러나 포인터 연산은 없음

Go에는 없는 기능
- 클래스
- 상속
- 생성자
- final
- 제네릭 (v1.18부터 제네릭 사용)

#

## 콘솔 출력 함수
### Hello goorm! 출력
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, goorm!")
}
```

### println , print
Go언어에서는 꼭 fmt 패키지를 import 하지 않아도 기본적으로 콘솔 출력 함수인 println과 print 함수를 지원합니다. 두 함수의 차이점은 출력 후 줄바꿈을 하느냐 안하느냐의 차이입니다.
println은 줄바꿈을 하고, print는 줄바꿈을 하지 않습니다. print에서 줄바꿈을 하기 위해서는 "\n"을 입력하면 됩니다.   
이 함수들은 함수 안에서의 연산식의 결과를 출력합니다. `fmt.Println(3+5)`는 8을 출력합니다.

### fmt
Go언어에서 콘솔 입출력을 위해서 fmt 패키지를 import 해서 사용합니다. Go언어에서 기본으로 제공하는 입출력 함수도 있지만, 조금 더 강력한 입출력 기능을 제공하는 fmt사용을 권장합니다.   
사용형태는 fmt.Println(출력하려는 데이터)

## 변수와 상수
### 변수의 선언과 초기화
Go에서 변수 선은 방식은 `var 변수이름 자료형` 입니다. 그리고 변수를 선언한 곳에서 바로 초기값을 설정할 수 있습니다.    
Go에서 변수를 선언할 때 가장 큰 특징은 `:=` (Short Assignment Statement) 입니다.
이를 사용해서 변수를 선언하면 자료형 선언 없이 타입 추론이 가능합니다. 하지만 이 용법은 함수(function)안에서만 사용 가능합니다. 함수 밖에서는 `var` 키워드를 사용해 변수를 선언해야 합니다.
```go
var a int = 1
var b string = "hello"
----------------------
c := 1
d := "hello"
```
그리고 Go에서는 변수를 선언하고 초기값을 설정하지 않으면 Zero Value로 설정됩니다.   
bool 타입은 false, 숫자 타입은 0, string 타입은 빈문자열로 설정됩니다.   

### 상수의 선언과 초기화
변수는 초기화된 이후 다른 값으로 수정될 수 있습니다. 하지만 상수는 한번 초기화되면 그 후에는 수정될 수 없습니다. 상수는 다은 언어들과 동일하게 `const` 키워드로 선언하고 초기화 합니다.   
선언 형태는 `const 상수이름 자료형` 입니다. 자료형은 생략 가능하며 함수 밖에서도 동일하게 사용 가능합니다.   
상수는 변수와 다르게 괄호`()`를 이요해 여러 개의 값을 묶어서 초기화할 수 있고, 다른 형이더라도 초기화할 수 있습니다.
```go
const (
    a = 1
    b = "hello"
)
```
- 괄호의 위치는 상관없지만 각 상수들은 줄바꿈을 하고 초기화해야 합니다.
- 각 상수 사이에 콤마(,)를 입력하면 에러가 발생합니다.
- 묶어서 선언된 상수들 중 첫번째 값은 꼭 선언되어야 합니다.
- 선언되지 않은 값은 바로 전 상수의 값을 가집니다.
- `iota`라는 식별자를 값으로 초기화하면 그 후에 초기화하지 않고 이어지는 상수들은 순서(index)가 값으로 저장됩니다.

```go
package main

import "fmt"

const ( 
	c1 = 10 //첫 번째 값은 무조건 초기화해야 함
	c2
	c3
	c4 = "goorm" //다른 형 선언 가능
	c5
	c6 = iota //c8까지 index값 저장
	c7
	c8
	c9 = "earth"
	c10
	c11 = "End"
)

func main() {
	fmt.Println(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)
}
// 10 10 10 goorm goorm 5 6 7 earth earth End
```

## 연산자
### 수식 연산자
수식 연산자는 두 개의 피연산자를 필요로 하고, 다른 언어들과 마찬가지로 기본적인 사칙연산과 값을 나눈 나머지 값을 반환하는 연산자가 있습니다.   
`+` 연산자는 문자열 결합이 가능합니다.
```go
package main 

import "fmt"

func main() {
	str1, str2 := "Hello", "goorm!"

	fmt.Println(str1 + str2)

	// Hellogoorm!
}
```

### 증감 연산자
증감 연산자는 값을 1 증가 또는 감소시키는 연산자입니다. Go언어에서는 증감 연산자를 사용하고 동시에 대입할 수 없습니다. 그리고 전위 연산을 할 수 없습니다.
```go
num := count++ // (x)
++count // (x)
```

### 할당 연산자
할당 연산자는 값을 단순히 대입하는 연산자와 연산 후 값을 대입시키는 복합 대입 연산자가 있습니다.
| 종류 | 기능                           |
| ---- | ------------------------------ |
| =    | 변수나 상수에 값을 대입        |
| :=   | 변수 선언 및 대입              |
| +=   | 값을 더한 후 대입              |
| -=   | 값을 뺀 후 대입                |
| *=   | 값을 곱한 후 대입              |
| /=   | 값을 나눈 후 대입              |
| %=   | 값을 나눈 후 나머지 대입       |
| &=   | 값의 AND 비트 연산 후 대입     |
| ㅣ=  | 값의 OR 비트 연산 후 대입      |
| ^=   | 값의 XOR 비트 연산 후 대입     |
| &^=  | 값의 AND NOT 비트 연산 후 대입 |
| <<=  | 비트를 왼쪽으로 이동 후 대입   |
| >>=  | 비트를 오른쪽으로 이동 후 대입 |

### 논리 연산자
논리 연산자는 다른 언어들과 같습니다. AND(논리곱), OR(논리합), NOT(논리부정)을 연산합니다. 주의할 점은 Go언어에서 논리부정 연산은 bool 형의 선언 및 사용만 가능합니다. 즉, false와 true 값만 사용할 수 있습니다.

### 관계 연산자
관계 연산자는 두 값의 대소와 도등의 관계를 따지는 연산자입니다. 조건을 만족하면 true, 만족하지 않으면 false를 반환합니다. 자바스크립트와 다른 관계 연산자만 정리했습니다.
| 종류 | 기능                |
| ---- | ------------------- |
| ==   | 두 값이 같은지 비교 |
| !=   | 두 값이 다른지 비교 |

### 비트 연산자
비트 연산자는 비트 단위의 연산을 진행하는 연산자 입니다. 기계에 좀 더 친화적인 연산자지만 다른 영역에도 사용돼 효율성을 높이고 연산의 수를 줄이는 요인이 되기도 합니다.

| 종류 | 기능                            |
| ---- | ------------------------------- |
| &    | 두 값을 비트 단위로 AND연산     |
| ㅣ   | 두 값을 비트 단위로 OR연산      |
| ^    | 두 값을 비트 단위로 XOR연산     |
| &^   | 두 값을 비트 단위로 AND NOT연산 |
| <<   | 값의 비트열을 왼쪽으로 이동     |
| >>   | 값의 비트열을 오른쪽으로 이동   |


### 채널 연산자
Go언어에는 채널이라는 개념이 있습니다. 채널과 고루틴(goroutine)끼리 데이터를 주고 받고 실행 흐름을 제어하는 기능을 합니다. 채널 연산자는 채널을 사용할 때 사용하는 연산자입니다.
| 종류 | 기능               |
| ---- | ------------------ |
| <-   | 채널의 수신을 연산 |

### 포인터 연산자
포인터 연산자는 &와 * 연산자를 이용해 메모리에 접근할 수 있도록 합니다. 주의할 점은 Go언어는 포인터 연산자를 제공하지만 포인터 산술(더하기, 빼기) 기능은 제공하지 않습니다.
| 종류 | 기능                                             |
| ---- | ------------------------------------------------ |
| &    | 변수의 메모리 주소를 참조                        |
| *    | 포인터 변수에 저장된 메모리에 접근하여 값을 참조 |

```go
package main

import "fmt"

func main() {
	var num int = 5
	var pnum = &num

	fmt.Println("num :", num)
	fmt.Println("pnum :", pnum)
	fmt.Println("pnum :", *pnum)
	// num : 5
	// pnum : 0xc82000a2d0
	// pnum : 5
}
```

#

### 콘솔 입력 함수
콘솔 입력 함수를 이용하면 프로그램 사용자가 값을 입력할 수 있습니다.    
fmt 패키지를 이용한 콘솔 입력 함수에는 Scanf, Scan, Scanln 등이 있고 가장 기본적으로 Scanln이 쓰이고 있습니다.   
Scanln은 여러 값을 동시에 입력받을 수 있습니다. 빈칸(스페이스바)로 값을 구분하고 엔터를 입력하면 입력이 종료됩니다. `&` 연산자를 변수에 붙여 입력을 받습니다.

```go
package main

import "fmt"

func main() {
	var num1, num2, num3 int

	fmt.Scanfln(&num1, &num2, &num3)
	fmt.Println(num1, num2, num3)

	// 1 2 3 입력
	// 1 2 3
}
```
#

## 자료형
Go언어에서 사용할 수 있는 자료형은 부울린(bool) 타입, 문자열 타입, 정수형 타입, 실수 타입, 복소수 타입 그리고 기타 타입들이 있습니다.   
-  `:=` 용법을 활용한 자료형 추론이 가능합니다.

### 부울린(Boolean) 타입
부울린 타입은 "참/거짓"을 할당할 수 있는 자료형입니다. 다른 언어에서는 0과 1로 참, 거짓을 표현할 수 있지만 Go언어에서는 오로지 `true false`만 사용하여 할당할 수 있습니다. 그리고 부울린 타입은 1바이트로 할당됩니다.

### 정수 타입
가장 많이 사용되는 정수형 타입입니다. uintptr 자료형은 포인터의 비트 패턴을 할당할만한 크기의 자료형입니다. 주로 포인터의 주소를 할당할 때 사용합니다. Go언어에서는 한눈에 자료형의 크기를 확인할 수 있게 int16, int32와 같은 형태로 표현합니다. 뒤에 붙은 숫자는 비트를 의미합니다.   
앞에 "un"이 붙은 자료형은 C언어와 다른 언어에서 사용되는 0과 양의 정수만 표현하는 'unsigned'와 같습니다.
| 선언    | 크기(byte)             |
| ------- | ---------------------- |
| int     | n비트 시스템에서 n비트 |
| int8    | 1                      |
| int16   | 2                      |
| int32   | 4                      |
| int64   | 8                      |
| uint    | n비트 시스템에서 n비트 |
| uint8   | 1                      |
| uint16  | 2                      |
| uint32  | 4                      |
| uint64  | 8                      |
| uintptr | 8                      |

### 실수 밑 복소수 타입
- 실수형
  - float32 : 4byte
  - float64 : 8byte

- 복소수형
  - complex64 : 8byte
  - complex128 : 16byte


### 문자열 타입
문자열 타입은 "" 와 같이 비어있을 수 있습니다. string으로 선언한 문자열 타입은 immutable 타입으로서 값을 수정할 수 없습니다.
```go
var str string = "hello"
str[2] = "a" // 불가능
```
- 문자열
  - string : 16byte


### 기타 타입
기타 타입은 byte와 rune 자료형이 있습니다. byte는 int8과 같은 자료형으로 바이트 값을 8비트 부호없는 정수 값과 구별하는데 사용됩니다. rune는 int32와 같은 자료형으로 볼 수 있습니다.

#

### 자료형 변환
Go언어에서는 형 변환을 할 때 변환을 명시적으로 지정해주어야합니다. float32에서 int로 자료형을 변환할 때 `int(변수이름)` 과 같이 변환을 지정해 주어야 런타임 에러가 발생하지 않습니다.
```go
package main

import "fmt"

func main() {
	var num int = 10
	var changef float32 = float32(num) //int형을 float32형으로 변환
	changei := int8(num)               //int형을 int8형으로 변환

	fmt.Println(num)
	fmt.Println(changef, changei)
	// 10
	// 10 10
}
```

#

### import "fmt"
import "fmt"를 선언해서 fmt 패키지를 사용할 수 있습니다. fmt 패키지는 콘솔 입력 함수와 콘솔 출력 함수를 사용할 수 있습니다.

### println, Print
| 선언    |                     출력 형태                      |
| ------- | :------------------------------------------------: |
| Println |                   개행 자동 추가                   |
| Print   |                  개행 자동 추가 X                  |
| Printf  | 포맷 지정자를 이용하여 개발자가 원하는 형태로 출력 |

Println은 자동으로 줄바꿈을 하고 출력됩니다. 그러나 Print 함수는 줄바꿈을 하지 않기 때문에 문자열 내에서 '\n' 을 입력해 줄바꿈을 해야합니다.    
두 함수는 하나의 인자를 출력할 수도 있고 여러 개의 인자를 콤마로 결합해 출력할 수 있는 공통점이 있습니다.

### Printf
Printf는 개발자가 반드시 포멧을 지정해줘야 합니다. `a := 5` 일때, `fmt.Printf(a)` 를 입력해 출력할 수 없습니다. `fmt.Printf("%d", a)` 의 형식으로 입력해야 출력이 가능합니다.   
C언어와 다른 점은 배열을 한번에 출력할 수 있는 것입니다. 그리고 Printf는 Printdhk 같이 자동 줄바꿈이 되지 않기 때문에 '\n' 을 입력해서 줄바꿈을 해야합니다.

```go
package main

import "fmt"

func main() {
	age, name := 24, "길동"

	fmt.Printf("안녕 난 %s이야\n", name)
	fmt.Printf("나이는 %d살이야\n", age)
	fmt.Printf("반가워")

	n := 14
	var arr [5]int = [5]int{1, 2, 3, 4, 5}
	
	fmt.Printf("내 동생은 %d살이야\n", n)
	fmt.Printf("%d \n", arr) //배열 한 번에 출력 가능
	fmt.Printf("%d %d", n, arr)
}

// 반가워내 동생은 14살이야
// [1 2 3 4 5] 
// 14 [1 2 3 4 5]
```

### 서식문자의 종류와 의미
| 서식문자 | 출력 형태                           |
| -------- | ----------------------------------- |
| %t       | bool                                |
| %b       | 2진수 정수                          |
| %c       | 문자                                |
| %d       | 10진수 정수                         |
| %o       | 8진수 정수                          |
| %x       | 16진수 정수, 소문자                 |
| %X       | 16진수 정수, 대문자                 |
| %f       | 10진수 방식의 고정 소수점 실수      |
| %F       | 10진수 방식의 고정 소수점 실수      |
| %e       | 지수 표현 실수, e                   |
| %E       | 지수 표현 실수, E                   |
| %g       | 간단한 10진수 실수                  |
| %s       | 문자열                              |
| %p       | 포인터                              |
| %U       | 유니코드                            |
| %T       | 타입                                |
| %v       | 모든 형식                           |
| %#v      | #을 이용해 구분할 수 있는 형식 표현 |

#

### Scanln, Scan, Scanf
|  선언  |                     입력 형태                      |
| :----: | :------------------------------------------------: |
| Scanln |               공백으로 구분하여 입력               |
|  Scan  |           공백과 개행으로 구분하여 입력            |
| Scanf  | 포멧 지정자를 이용하여 개발자가 원하는 형태로 입력 |

#
 
## 반복문 - for
### for
Go언어에서는 while문을 제공하지 않아 for문만 사용할 수 있습니다.   
for문의 쓰임새를 확장시켜 무한루프와 같은 기능도 for문으로 간결하게 구현할 수 있게 만들어졌습니다.
```go
for 초기식; 조건식; 조건 변화식 {
	반복 수행할 구문
}
```

```go
package main
 
import "fmt"
 
func main() {
	sum := 0
	
	for i := 1; i <= 10; i++ {
		sum += i
	}
	fmt.Println("1부터 10까지 정수 합계:", sum) // 1부터 10까지 정수 합계: 55
}
```

### 조건식만 쓰는 for 루프
Go언어에서는 for문에 조건식만 간결하게 표현이 가능해 while문과 동일하게 사용이 가능합니다.
```go
package main

import "fmt"

func main() {
	n := 2
	
	for n < 100 {
		fmt.Printf("count %d\n", n)
		
		n *= 2
	}
}
// count 2
// count 4
// count 8
// count 16
// count 32
// count 64
```

### 무한루프
다른 언어에서 무한루프를 만들 때 while(1)과 같은 방법을 사용합니다. Go언어에서는 `for {}` 와 같은 형식(모든 식을 생략)으로 무한루프가 가능합니다. 무한루프를 빠져나올땐 ctrl + c 를 입력합니다.
```go
package main

import "fmt"

func main() {
	for {
		fmt.Printf("무한루프입니다.\n")
	}
}
```

### for range문
이 문법은 다른 언어의 for each와 비슷한 문법입니다. 컬렉션으로부터 한 요소씩 가져와 차례로 for문의 블럭의 문장들을 실행합니다.   
- Go언어에서 컬렉션은 배열, 슬라이스(Slice), 맵(Map)이 있습니다.   
- ` var arr [3]int = [3]int{1, 2, 3}` 와 같은 형식으로 배열을 선언합니다.

for range문은 `for 인덱스, 요소값 := range 컬렉션이름` 과 같은 형식으로 루프를 구성합니다.
```go
package main

import "fmt"

func main() {
	var arr [6]int = [6]int{1, 2, 3}

	for index, num := range arr {
		fmt.Printf("arr[%d]의 값은 %d입니다.\n", index, num)
	}
}
// arr[0]의 값은 1입니다.
// arr[1]의 값은 2입니다.
// arr[2]의 값은 3입니다.
```

인덱스와 요소값을 모두 받아오지 않고 둘 중 하나를 생략해서 사용할 수 있습니다.
- `_, 요소값` : 인덱스 생략
- `인덱스` : 요소값 생략

#

## 조건문
### if
Go언어의 조건문은 반드시 Boolean 형으로 표현되어야 합니다. bool 형은 true와 false만 지원합니다. 다른 언어에서 조건식에 1, 0과 같은 숫자를 쓸 수 있는 것과 대조적입니다.

Go언어에서 조건문을 사용할 때 if 옆에 괄호를 생략해서 입력할 수 있습니다. 괄호를 생략해서 실행하는 것을 권장하지만 괄호를 쓴다고 해서 실행이 안되는 것은 아닙니다.

다른 언어에서 조건문이 한줄일 때 중괄호를 생략하는 경우가 있지만 Go언어에서는 반드시 중괄호를 입력해야 합니다.

if~else 또는 if~else if문을 사용할 때 반드시 조건문이 시작하는 첫 번째 줄에 블록 시작 브레이스(중괄호)를 입력해야 합니다. 그렇지 않으면 런타임 에러가 발생합니다.

Go언어에서는 조건식 앞에 변수를 선언하고 식을 입력할 수 있습니다. 조건식 앞에 정의된 변수는 조건문 블록에서만 사용할 수 있습니다.
```go
package main

import "fmt"

func main() {
	var num int

	fmt.Print("정수입력 :")
	fmt.Scan(&num)

	if val := num * 2; val == 2 {
		fmt.Print("hello\n")
	} else if val := num * 3; val == 6 {
		fmt.Print("world\n")
	} else {
		fmt.Print("worng number..\n")
	}
}
// 1
// hello
```

#

## 분기문
### switch
switch문은 기본적으로 변수를 가져와 switch 옆에 태그로 사용합니다. 태그의 값에 따라 case의 라벨과 일치하는 것을 찾고 일치하는 case구문을 수행합니다. 또한 태그만이 아닌 표현식을 쓰는 경우도 있습니다. case 옆에도 라벨뿐 아니라 참/거짓을 판별할 수 있는 표현식을 쓰는 경우도 있습니다. 태그나 표현식이 어느 조건에도 맞지 않는다면 dafault문을 사용해 해당 구문을 수행합니다.

if문처럼 블록 시작 브레이스(중괄호)를 같은 줄에 쓰지 않아도 실행됩니다. 그리고 break를 따로 입력하지 않아도 해당 case 구문만 수행합니다.

```go
package main
 
import "fmt"
 
func main() {
	var num int
	fmt.Print("정수 입력:")
	fmt.Scanln(&num)
	
	switch num {
	case 0:
		fmt.Println("영")
	case 1:
		fmt.Println("일")
	case 2:
		fmt.Println("이")
	case 3:
		fmt.Println("삼")
	default:
		fmt.Println("모르겠어요.")
	}
}
// 정수 입력: 3
// 삼
```

#

## 제어문
### break
break문은 해당 부분을 빠져나오는 용법입니다. for문만이 아닌 switch문과 select문에서도 사용할 수 있습니다. 
- break문은 break문이 있는 for문만 빠져나오게 됩니다.
- 보통 break문은 단독으로 사용되지만, 경우에 따라 'break 레이블이름'과 같이 사용되어 지정된 레이블로 이동할 수 있습니다. 해당 for문을 빠져나와 지정한 레이블로 이동한다는 뜻입니다.

```go
package main

import "fmt"

func main() {
	i := 0

TEST1:
	for {
		if i == 0 {
			break TEST1 // break로 for문을 빠져나가고 TEST1로 이동
		}				// break로 빠져나온 for문 다음 문장을 실행
	}
	
	fmt.Println("End") // End
}
```

### continue
continue문은 break문과 다르게 for문에서만 사용해야 합니다. continue문은 해당 반복문의 처음 부분으로 다시 이동합니다.
```go
package main

import "fmt"

func main() {

	for i := 1; i < 16; i++ {
		if i%2 == 0 {
			continue //반복문 처음 부분으로 간다
		}
		
		fmt.Printf("%d ", i)
	}
}
// 1 3 5 7 9 11 13 15
```

# 

## 컬렉션
### 배열
Go언어에서 배열은 정적입니다. 고정된 배열 크기 안에 동일한 데이터를 연속적으로 저장할 수 있습니다. 배열 크기를 동적으로 증가시키거나 부분 배열을 발췌하는 기능은 가지고있지 않습니다.   
배열의 선언은 `var 배열이름 [배열크기]자료형` 형식으로 나타냅니다. Go언어에서 배열의 크기는 자료형을 구성하는 한 요소입니다. [3]int 와 [5]int는 서로 다른 타입입니다.   
[...]을 사용하면 배열 크기를 자동으로 설정해줍니다. 하지만 이후에 크기를 바꿀 수 있는 것은 아닙니다.
```go
package main

import "fmt"

func main() {
	var arr1 [5]int   //길이가 5인 int형 배열 arr1을 선언
	fmt.Println(arr1) //숫자를 선언하지 않고 출력해보기

	arr1 = [5]int{1, 2, 3, 4, 5}        //배열 초기화
	fmt.Println(arr1, arr1[0], arr1[4]) //배열 전체와 인덱스에 저장된 값들 출력해보기

	arr2 := [4]int{4, 5, 6, 7} //:= 를 이용해 선언
	arr2[0] = 32               //인덱스를 이용해 값을 초기화
	fmt.Println(arr2)          //arr2 전체 출력해보기

	var arr3 = [...]int{9, 8, 7, 6} //[...]을 이용한 배열 크기 자동 설정
	fmt.Println(arr3, len(arr3))    //arr3 전체와  배열 크기 출력해보기
}
// [0 0 0 0 0]
// [1 2 3 4 5] 1 5
// [32 5 6 7]
// [9 8 7 6] 4
```

### 슬라이스(Slice)
슬라이스는 배열과 다르게 고정된 크기를 미리 지정하지 않고 이후에 필요에 따라 크기를 동적으로 변경할 수 있고 부분 발췌가 가능합니다. 따라서 슬라이스는 배열의 여러 제약점들을 넘어 여러 값을 다룰 때 주로 사용됩니다.   
슬라이스는 지금까지 배운 자료형과 내부적인 구조가 다르기 때문에 선언 및 초기화를 할 때 주의해야 합니다. 지금까지 변수 선언은 변수이름 자료형 형식으로 선언을 했습니다. 이 선언은 자료형의 변수가 들어갈 메모리를 만들었다 라는 말이고 초기값을 지정해주지 않으면 정수, 실수형은 0, 문자열형은 빈문자열이 자동으로 할당됩니다.    
하지만 슬라이스는 `var a []int` 와 같이 선언하면 배열의 일부분을 가리키는 포인터를 만들고 초기값을 할당하지 않습니다. 슬라이스는 크기를 미리 지정하지 않기 때문에 어느정도의 크기를 만들어야할지 알 수 없기 때문입니다. 따라서 슬라이스의 초기값을 지정하지 않고 선언한다면 'Nill slice'가 됩니다.   
슬라이스는 기본적으로 배열의 위치를 가리키는 ptr, 배열의 길이 len, 전체 크기 cap 메모리를 가지고 있습니다.    
슬라이스를 `var a []int` 와 같이 선언을 할 때는 선언과 동시에 초기화를 할 때만 사용합니다. 슬라이스를 선언함과 동시에 초기값을 위한 메모리를 만드는 것입니다.   
배열은 다른 배열의 값을 대입하면 값 자체가 대입됩니다. 하지만 슬라이스는 참조 타입이기 때문에 슬라이스를 복사해온다는 것은 사실 같은 주소를 참조한다는 것과 같습니다.
```go
package main

import "fmt"

func main() {
	var a []int        //슬라이스 변수 선언 아무것도 초기화 되지 않은 상태
	a = []int{1, 2, 3} //슬라이스에 리터럴값 지정

	a[1] = 10 //값이 할당되어 메모리가 생겼기 때문에 이렇게 접근 가능

	fmt.Println(a)

	var b []int //nil slice 선언

	if b == nil {
		fmt.Println("용량이", cap(b), "길이가", len(b), " Nil Slice입니다.")
		// [1 2 3]
		// 용량이 0 길이가 0 Nil Slice입니다.
	}
}
```

#### make()함수를 이용한 슬라이스 선언
make()함수를 이용하면 슬라이스를 선언만 하면서 크기를 미리 지정할 수 있습니다.   
`make(슬라이스 타입, 슬라이스 길이, 슬라이스 용량)` 형태로 선언합니다. 여기서 용량(Capacity)은 생략해서 선언할 수 있습니다. 용량을 생략한다면 길이와 똑같은 값으로 선언됩니다. 주의할 점은 make()함수를 이용해 슬라이스의 메모리를 할당하고 난 후에 `[]int{1,2,3,4}` 와 같은 식으로 값을 초기화하면 새로운 메모리를 할당하면서 그 전의 값은 없어집니다.

#### 슬라이스 추가, 병합, 복사
append()함수를 이용해서 슬라이스에 데이터를 추가할 수 있습니다. 슬라이스의 용량이 남아있는 경우에는 슬라이스의 길이를 변경하여 데이터를 추가하고, 용량을 초과하는 경우엔 설정한 용량만큼 새로운 배열을 생성하고 기존 배열 값들을 모두 새 배열에 복제한 후 다시 슬라이스를 할당하는 방식입니다.   
또한 슬라이스에 슬라이스를 추가해서 붙일 수 있습니다. 이때, 슬라이스 뒤에 '...'을 입력해야 합니다.
```go
package main

import (
	"fmt"
)

func main() {
	sliceA := make([]int, 0)
	sliceB := make([]int, 0)

	for i := 1; i <= 3; i++ {
		sliceA = append(sliceA, i)
		sliceB = append(sliceB, i)
	}

	sliceA = append(sliceA, sliceB...)

	fmt.Println(sliceA) // [1 2 3 1 2 3]
}
```
copy() 함수를 이용해 한 슬라이스를 다른 슬라이스로 복사할 수 있습니다. 
`copy(붙여넣을 슬라이스, 복사할 슬라이스)` 형식으로 사용합니다.
```go
package main

import "fmt"

func main() {
	sliceA := []int{0, 1, 2}
	sliceB := make([]int, len(sliceA), cap(sliceA)*2) //sliceA에 2배 용량인 슬라이스 선언

	copy(sliceB, sliceA) //A를 B에 붙여넣는다

	fmt.Println(sliceB) // [0 1 2 ] 출력
	println(len(sliceB), cap(sliceB)) // 3, 6 출력
}
```

슬라이스는 부분만 잘라서 복사할 수 있습니다.    
`붙여넣을 슬라이스 := 복사할 슬라이스[복사할 첫 인덱스 : 복사할 마지막 인덱스+1]` 로 원하는 부분을 복사할 수 있습니다.
```go
package main

import "fmt"

func main() {
	c := make([]int, 0, 3) //용량이 3이고 길이가0인 정수형 슬라이스 선언
	c = append(c, 1, 2, 3, 4, 5, 6, 7)
	
	l := c[1:3] //인덱스 1요소부터 2요소까지 복사
	fmt.Println(l) // [2 3]

	l = c[2:] //인덱스 2요소부터 끝까지 복사
	fmt.Println(l) // [3 4 5 6 7]
}
```

### 맵(Map)
맵은 `key: value` 형식으로 값을 매핑해서 저장합니다. 그리고 슬라이스와 마찬가지로 값을 직접적으로 저장하는 것이 아닌 참조 타입입니다.   
맵은 `var 맵이름 map[key자료형]value자료형` 형식으로 선언합니다.
```go
package main

import "fmt"

func main() {
	var a map[int]string

	if a == nil {
		fmt.Println("nil map") // nil map
	}

	var m = map[string]string{ //key:value, 형식으로 초기화한다
		"apple":  "red",
		"grape":  "purple",
		"banana": "yellow",
	}

	fmt.Println(m, "\nm의 길이는", len(m))
	// map[apple:red banana:yellow grape:purple]
	// m의 길이는 3
}
```
#### map 변수의 추가, 갱신, 삭제
맵 컬렉션에 값을 추가하기 위해서는 `맵이름[key] = value` 형식으로 추가할 수 있습니다. 주의할 점은 이미 있는 key값에 다시 다른 value값을 저장한다면 최근 저장한 값으로 갱신됩니다.   
그리고 `delete(맵이름, key)` 형식으로 key값에 해당되는 value값을 삭제할 수 있습니다.
```go
package main

import "fmt"

func main() {
	//지역번호와 지역 저장
	var m = make(map[string]string)

	m["02"] = "서울특별시"
	m["031"] = "경기도"
	m["032"] = "충청남도"
	m["053"] = "대구광역시"

	fmt.Println(m) // map[02:서울특별시 031:경기도 032:충청남도 053:대구광역시]

	//동일한 key값으로 value값을 저장하면 갱신이 된다
	m["032"] = "인천"

	fmt.Println(m) // map[02:서울특별시 031:경기도 032:인천 053:대구광역시]

	//m에 있는 "031"key의 value와 함께 삭제
	delete(m, "031")

	fmt.Println(m) // map[02:서울특별시 032:인천 053:대구광역시]
}
```

맵에서 key와 value를 읽기 위해서는 `맵이름[key]` 형식으로 읽을 수 있습니다. `맵이름[key]` 는 key에 저장돼있는 value 값 뿐만 아니라, 해당 키가 사용중인 key값인지 판별해주는 true/false 값도 반환합니다.  value 값과 trure/false 값을 반환받기 위해서는 변수 두 개를 선언한 수에 각각 할당받아야 합니다. `val, exist := 맵이름[key]` 형식으로 입력해야 합니다.