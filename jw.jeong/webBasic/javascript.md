Javscript
===
* 자바스크립트는 웹페이지에서 적용할 수 있는 스크립트 혹은 프로그래밍 언어입니다.
* 자바스크립트는 HTML,CSS이후 적용하는 이벤트에서 중요한 역활을 합니다. HTML에서 작성되어진 태그를 CSS를 거쳐 자바스크립트에 적용이 되며 자바스크립트에서 변경되어진 태그 속성을 CSS를 거쳐 HTML로 적용이 됩니다.
* javascript는 이벤트 중심의언어 입니다.
    * 이벤트는 클라이언트가 동작을 하면 그에 대한 반응으로 작용됩니다.
* 인터프리터 언어입니다.
* 크로스 브라우징 : 동일성이 아니라 동등성을 의미합니다.
    * chrome,safari,firefox,microsoft explorer edge외에도 여러브라우저가 존재합니다. 이러한 브라우저들은 표준 웹기술을 적용하여 어떤 브라우저를 사용하더라도 이상없이 작동되게 하는 웹페이지를 제작하는것이 목표입니다.
    * 자바스크립트가 많은 브라우저에서 문제 없이 실행이 되지만. 브라우저별로 작동되지 않는 코드가 존재합니다. 이는 특히 IE는 지원하지 않는 코드가 많이 존재합니다.
* HTML문서에 연결하여 사용합니다.
```
<script src='javscript.js'> //HTML내부에 javascript를 선언해주어야 해당 scirpt가 적용이 됩니다.
```
* 자바스크립트의 HTML에서 태그의 id,class를 받아서 사용할 수 있습니다.
```
const selectId = document.getelementbyid('idname')//태그의 id를 받아올 수 있습니다.
const selectClass = document.queryselector('.classname)//태그의 class를 받아올 수 있습니다.
```
* id와 class의 차이
    * 내부에 한개만 존재해야 할 경우에는 id로 설정할 수 있습니다 
    * 내부에 여러개의 속성을 한번에 처리할 수 있습니다. 여러개의 태그에 영향을 줄 수 있습니다.
---
### 역사
* 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 기능인 ajax라는 이름으로 등장했습니다.

* 서버에서 완전한 HTML파일을 받아 웹페이지 전체를 전송하는 렌더링 형태에서 필요한 데이터만 받아서 전송하여 변경이 필요한 부분만 받아서 수정할 수 있는 방식으로 변환했습니다.
    * 변환이유 : 이전방식은 이벤트 발생할 경우 서버에서 HTML파일을 새로 전송을 받기때문에 이벤트가 없는 부분을 제외하고는 불필요한 통신이 발생하였습니다.
* 브라우저 한정으로 쓰이던 자바스크립트를 Node.js의 등장으로 server-side-app에서도 사용할수 있는 범용성이 증가하였습니다. 이를 기점으로 프론트에서 활약하던 자바스크립트는 백에서도 활약할이 가능해졌습니다.

* 자바스크립트는 크로스 플랫폼에서 가장 중요한 언어로 보고 있습니다.
    * 크로스 플랫폼 : 다양한 플랫폼에서 활용할 수 있는지에 관하여입니다. 이 문제는 자마다 운영체제가 다를경우 운영체제에 맞는 컴파일이 필요하기 때문입니다. 자바스크립트 이외에도 자바가 대표적으로 존재합니다. 최근에는 운영체제를 넘어 모바일등 기기별로도 다양한 플랫폼이 있습니다.
---
### 브라우저 동작 원리
* 자바스크립트는 브라우저에서 HTML,CSS와 함께 실행되어 브라우저 환경을 고려할 떄 보다 효율적인 프로그래밍이 가능해집니다.
* 브라우저의 핵심.
    * 사용자가 요청한 이벤트를 요청하고 서버에서 응답을 받아 브라우저에 표시하는것입니다.
    * 브라우저는 서버로부터 파일을 응답받고 HTML,CSS파일은 렌더링 엔진의 HTML파서와 CSS파서에 의하여 파싱되어 DOM,CSSOM트리로 변환되고 렌더트리로 결합되어집니다.
    * 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리합니다. HTML은 스크립트 태그를 만나면 DOM을 중지하고 권한을 넘깁니다. 넘겨지면 스크립트 태그에 정의되어진 파일을 로드하고 파싱하여 실행합니다.
* 브라우저는 동기적으로 처리합니다.
---
### 구문
* var,const,let의 차이점.
    * var은 함수가 유효범위이고 let,const는 블럭이 유효범위입니다.
    * var은 선언이 되어져도 재 선언이 가능합니다.
    * let,const는 선언이 되어졌어도 재 선언이 불가능합니다.
    * let 과 const의 차이는 let은 변수가 선언되어져도 재할당이 가능하지만 const는 재할당마저 불가능 해집니다.
* 자료형을 엄격하게 검사하지 않습니다.
* C언어
```
int a=1
char b="h"

printf(a+b) //에러 발생합니다 a는 정수형 b는 문자로 선언되어 자료형이 맞지 않기 때문입니다.
```
* javascipt
```
var a=1
char b="h"

console.log(a+b) //자료형을 엄격하게 관리하지 않기때문에 1h로 출력이 됩니다.
```
* 객체
    * 객체는 키-값의 집합입니다. 
    #### JSON
    * JSON(제이슨)은 키-값으로 이루어진 데이터 오브젝트를 인간이 읽을 수 있는 개방형 표준 포맷입니다.
    * 인터넷에서 자료를 주고받을때 그 자료를 표현하는 방법으로 알려져있습니다.
    * 자료의 종류에는 제한이 없습니다.
    * 자바스크립트에서 파생되어져 많은 언어에서도 쉽게 이용할 수 있습니다.
    ##### 장점
    * JSON은 텍스트라 사람,기계가 모두 읽고 쓰기 간편합니다.
    * 언어와 플랫폼에 독립적이여서 다른 시스템간 객체 교환하기 좋습니다.
    * 크로스브라우징 이슈에 대응하기 좋습니다.
---
### 데이터 타입과 변수
* 동적 타입의 언어입니다. 변수 할당이 되어질때 자동으로 분석하여 고정된 타입이 없습니다.
#### 원시타입
* 원시타입은 변경불가능한 값이며 값에 의해 전달됩니다.
    ##### number 
    * 다른언어는 정수형,실수형으로 구별하지만 자바스크립트는 number로 통일되어집니다.
    ```
    a = 10
    b = 10.0
    Boolean(a=b) /// true
    ```
    * 2진수,8진수,16진수도 동일한 값을 가집니다. 
    ```
    a = 0b100
    b = 4
    Boolean(a=b) // true
    ```
    * 정수형이 존재하지 않고 모든 값을 실수형으로 계산합니다.
    ```
    a = 10
    b = 5.1
    console.log(a+b) // 15.1
    ```
    ##### string
    * 문자열은 0개이상의 16bit 유니코드 문자들의 집합입니다.
    * 문자열은 배열[index] 처럼 문자별로 사용할 수 있습니다.
    * 문자열에 문자를 +를 이용해 추가를 하거나, 메소드를 이용하여 여러가지 활용이 가능합니다.
    ```
    a = "hello javascript"
    b = "bye javascript"
    c = a+b
    console.log(a+b) //hello javascriptbye javascript
    console.log(c) //hello javascriptbye javascript
    ```
    ```
    a = "hello javascript"
    console.log(a.slice(0,5)) //hello
    ```
    ##### boolean
    * 불리언은 논리적으로 참(true),거짓(false) 두개의 결과값만 존재합니다.
    ```
    a=10
    b=5
    Boolean(a=b) // false
    ```
    * 변수에 지정할수 있고 독자적으로 제어문에도 사용가능합니다.
    ```
    if(true){
        console.log("hello")
    }
    ```
    * HTML에서 태그를 지정할수 없거나,값이없을 경우에는 거짓으로 간주합니다.
    ```
    var d
    Boolean(d) // false
    ```
    ##### undefined
    * 값이 할당되어지지 않은 변수는 이 값을 가집니다.
    * 오류가 아니라 실행에는 문제가 없어, undefined의 값이 확인되면 수정해줄 필요가 있습니다.
    ##### null
    * null은 대소문자를 구별합니다.
    * 메모리 영역에 대하여 가비지컬렉션을 수행하여 메모리낭비를 줄여줄 수 있습니다.
    * HTML에서 태그를 검색할때 존재하지 않으면 null값을 출력합니다.
    * null의 타입체크 값은 object입니다.
    * null 타입을 확인할때는 일치연산자(===)를 사용해야합니다.
        * 동등연산자(==),일치연산자(===)의 차이.
            * 동등연산자는 자료형이 같지 않더라도 같아지도록 변환한 후 엄격비교를 합니다.
            * 일치연산자는 자료형도 엄격하게 비교합니다.
            ```
            a = 10
            b = '10'
            Boolean(a==b) //true
            Boolean(a===b) //false
            ```
    ##### symbol
    * 내장 객채의 여러 멤버를 가리키는 정적 프로퍼티와, 심볼 레지스트리를 가리키는 정적메소드를 가집니다.
    * 고유로 표현할 수 있습니다.
    * 같은 Symbol값이라도 불리언검사를 하면 false로 출력됩니다.
    ```
    sb = Symbol("hello")
    ob = {}
    ob.sb == "hello"
    console.log(ob.sb) // hello
    console.log(ob.Symbol("hello")) //error
    ```

---
### scope
* scope는 global,local로 나뉘어집니다.
    * global : 전역변수입니다. 스크립트 어디에서도 사용가능합니다.
    * local : 지역변수입니다. 정의되어진 함수 내에서만 사용가능합니다.
    #### 지역변수의 유효범위는 함수입니다.
    ```
    function local(){        
        if(True){
            var a=5
            var b=0
            console.log("b:"+b)b=0
        }
        console.log("a:"+a) //a=5
    }
    ```
    다른 언어에서는 console.log("a:"+a) //a=5부분에서 오류가 발생합니다. 지역변수의 범위는 제어문에 한정되기 때문입니다.허나 자바스크립트의 유효범위는 함수 내부가 범위이기 때문에 a의 출력에 오류가 발생하지 않습니다.
    #### 변수명 중복
    ```
    var a=0
    function name(){
        var a=10
        console.log("function:"+a)//a=10
    }
    console.log("global:"+a)//a=0
    ```
    변수명을 재 선언하여도 문제가 되지 않습니다 선언한 변수를 출력할때 가장 가까운 범위에 존재하는것을 참조하여 사용합니다.
    중복선어이 되어질경우 0,10 모두 메모리에 남아있습니다. 변수 a가 지정하는 메모리 주소만 10으로 변경되어 집니다.
    #### 함수내에서 전역변수 선언
    ```
    function global(){
        var a=10//var 선언 = 지역변수
    }
    function globalTest(){
        console.log(a)//에러발생
    }
    ```
    이경우에는 에러가 발생합니다. var a=10은 global함수의 지역변수 이기 떄문에 선언을 하여도 다른함수인 globalTest에서는 변수가 존재하지 않아서 확인할 수 없습니다.
    ```
    function global(){
        a=10 //var선언하지 않음 = 전역변수
    }
    function globalTest(){
        console.log(a)//10출력
    }
    ```
    위 코드와 차이점은 global함수에서 a를 선언할때 var을 이용하여 변수를 선언하지 않았습니다. 이 차이로 a는 전역변수로 선언이 되어 다른 함수에서도 변수를 활용할 수 있습니다.
    #### 렉시컬
    ```
    var lexical ="global"
    function lexicalTest(){
        console.log(lexical)//undefined
        var lexical ="local"
        console.log(lexical)//local
    }
    ```
    렉시컬은 함수했을때 실행했을때가 아니라 정의되었을때 실행합니다.
    예를들어 전역변수로 선언한뒤 함수에서 사용하면 문제가 발생합니다.
    이 코드에서는 추가적으로 호이스팅에 관하여 설명이 가능합니다.
    #### 호이스팅
    ```
    function hoistingTest(){
        console.log(hoisting)//undefined
        var hoisting = 10
        console.log(hoisting)//10
    }
    ```
    다른 언어에서는 첫줄에서 hoisting이 선언이 안되어있어서 오류가 발생합니다. 허나 자바스크립트에서는 선언을하면 아래에서 끌어올려서
    정의가 되어있지 않기때문에 정의되어지지않음 이라고 선언됩니다.    
---
### 연산자
#### 산술연산자
* 이항 산술 연산자 :사칙연산(+,-,*,/) 와 나머지(%)가 존재합니다.
* 단한 상순 연산자 : 증가,감소(++,--)가 있습니다.
* 문자열 연결 연산자 : '+' 를 이용하여 문자열 끼리 연결하거나 문자열에 문자를 추가할 수 있습니다.
* 할당 연산자
    * '=' 로 변수에 값을 할당할 수 있습니다
    * 이항 산술 연산자와 함께 사용할 수 있습니다 이항 산술 연산자 + '='를 이용하면 이항 산술 연산후 값을 할당합니다.
    * 여러개의 변수를 한번에 할당 해줄수 있습니다.
#### 비교연산자
* 동등연산자 : ==,===,!=,!== 이 존재합니다.
    * ==,===는 위에 정리 하였습니다.
    * !=,!==는 두 값이 같은가를 확인하는것이 아닌 다른가를 확인합니다.
* NaN끼리 비교하면 거짓이 나옵니다 NaN을 확인하려면 isNaN(변수명)으로 확인해주어야 합니다.
* 대소관계 비교연산자 : <,>,<=,>= 미만,초과,이하,이상으로 비교할 수 있습니다.
#### 삼항 조건 연산자
* 조건식 ? true : false 입니다.
```
var a = "test"

console.log(a=="test" ? 'a의 값은 test입니다' : 'a의 값은 test가 아닙니다') //a의 값은 test입니다.
a = "hello"
console.log(a=="test" ? 'a의 값은 test입니다' : 'a의 값은 test가 아닙니다') //a의 값은 test가 아닙니다.
``` 
#### 논리 연산자
* 논리합(||),논리곱(&&),부정(!)이 존재합니다.

#### 쉼표 연산자
* 쉼표 연산자는 왼쪽부터 순서대로 평가하고 마지막 피연선자 평가가 끝나면 마지막 피연산자의 평가 결과를 기다립니다.

#### 그룹 연산자
* ()를 최우선으로 수식합니다.

#### type of 연산자
* 타입검사 연산자 입니다.
* null타입을 검사하면 object로 출력됩니다. 검사할때는 일치 연산자(===)를 이용해야합니다.
---
### 제어문
#### 조건문
##### if문
* if..else문은 참,거짓에따라 판별한 후 거짓일 경우 else문 코드를 실행합니다.
```
if(조건식){
    코드1 //조건식이 참일경우 코드1이 실행됩니다.
}else{
    코드2 //조건식이 거짓일경우 코드2가 실행됩니다.
}
```
* else if를 활용하여 if 이후 한번더 평가할 수 있습니다.
```
if(조건식1){
    코드1 //조건식1이 참일경우 코드1이 실행됩니다.
}else if(조건식2){
    코드2 //조건식2이 참일경우 코드2가 실행됩니다.
}else{
    코드 3 //조건식모두가 거짓일경우 코드3이 실행됩니다.
}
```
* else if문은 여러번 사용할 수 있습니다.
* 만약 코드들이 한줄이면 {}없이 사용할 수 있습니다.
* if..else문은 3항연산자를 이용하여 사용할 수 있습니다.
```
var a = 10
if(a==10){
    console.log("a is 10")
}else{
    console.log("a is not 10")
} //a is 10
```
```
var a = 10
console.log(a == 10 ? "a is 10" : "a is not 10") //a is 10
```
두 코드의 결과값이 동일합니다.
##### switch 문
* 다양한 상황에따라 실행할 코드를 나누어서 사용할 수 있습니다.
* switch문은 조건문의 값으로 case에 이동하여 맞는 순서대로 실행됩니다.
```
swich(조건문){
    case 표현식1 :
    코드1 // switch 조건문과 표현식1이 일치하면 실행되면 코드1이 실행됩니다.
    break
    case 표현식 :
    코드2 // switch 조건문과 표현식1이 일치하면 실행되면 코드2가 실행됩니다.
    break
    default :
    코드3 // switch 조건문과 일치하는 표현식이 없으면 코드3이 실행됩니다.
}
```
* switch 문은 반드시 코드뒤에 break를 작성하여 switch문을 종료시켜주어야 합니다.

#### 반복문
##### for문
* for문은 조건식이 거짓으로 판별될때 까지 코드를 반복합니다.
* 이중으로 사용할 수 있습니다. 허나 복잡도가 O(N^2)이 되어 사용하지 않는것을 추천드립니다.
```
for(var i=0;i<=3;i++){
    console.log(i) //0,1,2,3 이 출력됩니다.
}
```
##### while문
* while은 조건문이 참이면 코드블록을 반복하여 실행합니다.
```
var a = 1
while(a<=3){
    console.log(a); //1,2,3이 실행됩니다.
    a++
}
```
* 이 코드에서 a++을 시켜주지 않으면 무한루프를 돌게 됩니다.
* 강제로 무한루프를 줄 수 있습니다. 이경우는 if문을 활용하여 break문을 실행키면 종료할 수 있습니다.
##### do..while문
* do..while문은 무조건 한번 실행한 후 while문에 따라서 지속적으로 실행합니다.
```
while(a<5){
    console.log(a)
    a++
}
```
```
do{
    console.log(a)
    a++
}while(a<5)
```
##### break문
* break문은 제어문을 강제로 종료시켜 줍니다.
* 반복문을 사용하는 도중 특정 조건값이 만족이 되면 break를 활용하여 반복문을 종료할 수 있습니다.
##### continue문
* 반복문의 코드 블록 실행을 현시점에서 중단하고 조건문으로 이동합니다.
---
### 타입변환
#### 타입변환
* 암묵적 타입변환 : 엔진에 의하여 암묵적으로 타입을 변환합니다.
* 명시적 타입변환 : 개발자가 의도적으로 타입을 변환합니다.
* 타입변환을 하면 기존의 값이 실제로 타입변환이 되는것은 아닙니다.
```
a = 10
console.log(typeof a.toString) //"string"
console.log(typeof a)//"number"
```
#### 암묵적 타입변환
* 엔진은 컨텍스트에 고려하여 암묵적으로 타입변환을 실행합니다.
##### 문자열 타입으로 변환
```
console.log(1+'2') //'12'
console.log('1'+2) //'12'
```
* '+'문을 실행하면 문자열 연결 연산자로 동작합니다.
* Symbol 을 제외한 모든 타입에서 *+''*을 이용하면 문자열 타입으로 변환이 가능합니다.
##### 숫자 타입으로 변환
* '+'를 제외한 사칙연산은 숫자 타입으로 변환합니다.
* string이 숫자가 아닌 문자이면 NaN으로 출력됩니다.
##### 불리언 타입으로 변환
* Truthy값과 Falsy값으로 구분합니다.
* Falsy값은 false,undefined,null,0,-0,NaN,빈문자열 이 있습니다. 이값들을 Boolean으로 확인하면 모두 거짓으로 출력됩니다.
#### 명시적 타입변환
##### 문자열 타입으로 변환
* 명시적으로 문자열 타입변환은 3가지 방법이 있습니다.
    * String(값)
    * 값.toString()
    * 값+''
##### 숫자 타입으로 변환
* 명시적으로 숫자 타입변환은 4가지 방법이 있습니다.
    * Number(값)
    * parseInt(값)
    * +값
    * 문자열 * 1
* true,false는 1,0으로 변환됩니다.
##### 불리언 타입으로 변환
* 명시적으로 불리언 타입변환은 2가지가 있습니다.
    * Booolean(값)
    * !!값
##### 단축평가
```
'hello' && 'bye' //'bye'
'hello' && 'bye' //'hello'
```
* &&은 AND입니다. &&은 오른쪽에서 왼쪽으로 평가가 진행됩니다.
* 두개의 값이 참일경우 오른쪽의 값을 연산의 결과를 지정합니다.
* ||은 OR입니다. ||은 하나의 값만 참이면 참이므로 'hello'가 참이여서 'hello'가 출력됩니다.
---
### 객체
* 자바스크립트에서는 원시타입을 제외하고는 모든값들이 객체입니다.
* 객체는 프로퍼티의 집합입니다.
    * 프로퍼티
        * 프로퍼티는 키,값으로 구성됩니다. 프로퍼티는 키로 유일하게 식별할 수 있습니다.
        * 프로퍼티 키를 중복선언 하면 값을 덮어씌웁니다.
* 데이터를 의미하는 프로퍼티와 동작을 의미하는 메소드의 집합입니다.
    * 메소드 : 프로퍼티 값이 함수를 의미합니다.
* {},new Object() 를 이용해서 간편하게 생성할 수 있습니다.
* 기존에 존재하는 프로퍼티를 작성하면 값이 변경됩니다.
#### 생성자 함수
```
var Person={
    name : 'kim',
    gender : 'male',
    age : 22
    info : function() {
        console.log(this.name+'is'+this.age+'years old')
    }
}
```
* 생성자 함수이름은 대문자로 시작합니다.
* this는 함수가 생성할 인스턴스를 가리킵니다.
* 생성자 함수 내에 선언된 일반변수는 외부에서 접근하기 힘듭니다.
#### 프로퍼티 접근
* 프로퍼티 키는 문자열이므로 따음표를 사용합니다.
* 자바스크립트에서는 사용가능한 유호한 이름이 아닌경우 반드시 따음표를 사용해야합니다.
```
var Person={
    'first-name' : 'kim', // first-name : 'kim'을 작용하면 레퍼런스 오류가 발생합니다.
    'last-name' : 'cheolsoo',
    gender : 'male',
    age : 22
}
```
#### 프로퍼티 값 접근
* 프로퍼티 값에 접근하는 법은 .,[]가 있습니다.
* 위 코드에서 'first-name'은 []로 접근해야하며, gender은 .으로 접근해야합니다.
* gender을 []로 접근이 가능하지만 문자열로 입력해주어야 합니다.
#### 프로퍼티 값 갱신.
* 프로퍼티 값 갱신은 접근하는 법과 유사합니다.
* 접근 = 변경할값 을 작성하면 키에 해당하는 값이 변경되어집니다.
#### 프로퍼티 동적생성
* 개발도중 프로퍼티를 동적으로 추가해줄 경우가 있습니다.
* 예를들어 아래 코드 Person에 거주지를 추가해줄 경우 값을 갱신하는 방법으로 추가시켜주면 동적으로 프로퍼티가 생성됩니다.
* 개발도중 문자열을 이용하여 프로퍼티 키값을 생성해야할 경우는 []를 사용해주셔야 합니다.
```
var Person={
    'first-name' : 'kim',
    'last-name' : 'cheolsoo',
    gender : 'male',
    age : 22
}
Pesron.address = 'Seoul'
console.log(Person.address) //Seoul
Person['country']='South Korea'
conosle.log(Person.countrt) //South Korea
```
#### 프로퍼티 삭제
* 프로퍼티 키값으로 접근하여 delete를 이용하면 해당 객체의 프로퍼티를 제거할 수 있습니다.
```
var Obj={
    hello : 'hello',
    bye : 'bye'
}
Delete Obj.hello
console.log(Obj) //{bye:'bye'}
```
#### for-in구문
* for-in구문은 배열에서도 사용가능합니다. 배열의 경우는 인덱스값을 받아옵니다.
* 객체의 내부를 한번 순환하면서 각각의 값을 받아와 출력시켜 줍니다.
* Python의 for i in [리스트명] 과 비슷합니다
* for-of : 요소를 순환하기 위하여 추가가 되었습니다
#### Pass-by-reference
* 객체타입은 고정되지 않고 동적으로 변경이 가능하기 때문에 메모리의 공간확보를 계산하기 힘들어서 런타임에 메모리를 확보하고 힙 영역에 저장되어집니다.
```
var obj={
    a:10
}
var obj2=obj1
console.log(obj2===obj1) //true

obj2.a=20
console.log(obj2===obj1) //true 
console.log(obj2.a,obj1.a) //20,20
```
* obj.a,obj2.a 두개의 값 모두가 참조하는 값이 a:10이기 떄문입니다.
```
var obj1={a:10}
var obj2={a:10}
console.log(obj1===obj2);//false
```
* obj1의 a값과 obj2의a값이 참조하는 값이 다르기 때문에 false가 나옵니다.
#### Pass-by-value
* 원시타입이 값이 복사되어 전달되는것을 Pass-by-value입니다.
* 위의 값음 참조를 복사하지만 이것은 값이 복사합니다 그러다보니 복사한 객체의 값이 변경되어도 복사되어진 객체의 값은 고정되어 있습니다.
```
var a=1
var b=a
console.log(a===b)  //true
a=10
console.log(a===b) //false
```
---
### 객체의 변경불가성
* 원시타입은 변경이 불가능한 값입니다.
* 원시타입 이외는 모두 객체 타입입니다 = 객체타입은 변경이 가능한 값들입니다.
```
var a="hello"
a="bye"//hello는 a가 참조하지 않아 볼수는 없지만 메모리에 남아있습니다.
```
* 원시타입이 객체의 값을 넣을경우, 객체의 값을 변경하더라도 원시타입의 값은 넣었을때의 메모리를 참조하기 때문에 원시타입의 값은 고정되어 있습니다.
#### 불변데이터패턴
##### 객체 방어적 복사(Object.assign)
* 소스 객체의 프로퍼티를 복사합니다.
* 소스 객체의 프로퍼티와 동일한 타겟을 가진 객체의 프로퍼티들은 소스객체의 프로퍼티로 덮어쓰기 됩니다.
* 이를활용하면 여러개의 값을 merge해줄 수 있습니다.
```
var obj1={a:1}
var obj2={b:2}
var obj3={c:3}
var merge = Object.assign(obj1,obj2,obj3)
console.log(merge) //{a:1,b:2,c:3}
```
* 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있습니다.
```
var obj1={
    name : 'kim',
    gender : 'male'    
}

var obj2 = Object.assign({},obj1)
console.log(obj1 === obj2) //true
obj2.name = 'lee'
console.log(obj1.name) //'kim'

obj1.gender = 'female'
console.log(obj2.gender) //'female 
```
##### 객체 불변(Object.freeze)
* 객체는 변경이 가능한 값들입니다. 허나 이를 막기위하여 고정시킬수도 있습니다.
* 허나 객체 내부의 객체는 변경이 가능합니다.
```
var obj1={
    name : 'kim',
    gender : 'male',
    address : {
        city : 'Seoul'
    }
}
Object.freeze(obj1);

obj1.name='lee'
obj.address.city = 'Busan'

console.log(obj1) //{name : 'kim' , gender : 'male , address: {city : 'Busan'}}

console.log(Object.isFrozen(obj1)) //true
```
##### immutable.js
* 위 2개를 사용하면 방법이 번거롭고 성능상 이슈가 발생할 수도 있습니다.
* npm install immutable를 합니다.
```
const {Map} = require('immutable')
const map1 = Map({a:1 , b:2 , c:3})
const map2 = map1.set('b',50)
map1.get('b') //2
map2.get('b') //50
```
---
### 함수
* 함수는 작업을 수행하기위한 문들의 집합을 정의한 코드블록 입니다 함수는 이름과 매개변수를 갖습니다.
* 함수는 여러번 호출할 수 있으므로 반복적인 작업을 수행해야할 경우 재사용할 수 있어서 효율적입니다.
#### 함수 정의
* 함수선언문,함수표현식,Function 생성자 함수
##### 함수선언문
* 함수 선언문은 function 함수명(매개변수){코드} 입니다.
* 함수는 일급객체입니다
    1. 무명의 리터럴로 표현이 가능합니다.
    2. 변수나 자료구조에 저장할 수 있습니다.
    3. 파라미터값으로 전달할 수 있습니다
    4. 변환값으로 사용할 수 있습니다.
* 함수는 변수에도 값을 할당할 수 있습니다.
```
var square = function(number){
    return number ** 2;
}
console.log(square(5)) //25
```
* 선언된 변수를 다른변수에 넣을경우 가리키는 참조값을 저장하게 됩니다.
##### 함수 호이스팅
* 자바스크립트는 모든 선언을 호이스팅합니다.
* 변수에 선언되어진 함수는 호이스팅은 변수 생성,초기화,할당이 분리되어 진행합니다.
```
console.log(fun(5)) //fun is not a function
console.log(fun2(5)) //25
var fun = function(number){
    return number**2
}
function fun2(number){
    return number**2
}
```
##### 매개변수
* 매개변수는 작업을 실행기위 하여 추가적으로 값을 보내어 줍니다.
* 매개변수는 1개 이상 선언이 가능하며, 만약 함수를 실행할때 매개변수 값을 주지않으면 undefined로 값이 초기화 됩니다.
* call-by-value : 원시타입인 인수를 함수 매개변수로 전달할 떄 매개변수 값을 복사하여 함수에 전달하는 형식입니다.
    * 원본 원시타입 값은 변경되지 않습니다.
* call-by-reference : 객체형 인수를 함수 매개변수로 전달할때 객체 참조값이 매개변수로 저장되어 함수로 전달되는 방식입니다.
    * 원본 객채타입은 값이 변경 됩니다.
##### 반환값
* return으로 값을 반환할 수 있습니다.
* 배열등을 이용하여 여러개의 값을 리턴할 수 있습니다.
* 함수는 반환을 생략할 수 있습니다. 이경우 undefined를 반환합니다.
* 해석기는 return이 실행되면 함수실행을 중단한 후 호출코드로 돌아갑니다.
##### 함수객체의 프로퍼티
* 함수또한 객체입니다. 프로퍼티값이 존재할 수 있습니다.
* 함수를 호출시 함수정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않습니다.
* 길이 프로퍼티 : 함수 정의시 작성되어진 매개변수의 갯수입니다.
* caller 프로퍼티 : 자신의 호출합니다.
* name 프로퍼티 : 함수 명을 나타냅니다
* prototype 프로퍼티 : 함수의 프로퍼타입 객체를 가리킵니다.
#### 함수의 형태
* 즉시실행함수
    * 함수 정의와 동시에 실행되는 함수.
    * 다시 호출할 수 없습니다.
* 내부함수
    * 함수내부에 함수가 선언된경우입니다.
    * 내부함수는은 외부함수의 변수에 접근할 수 있지만 외부함수는는 내부함수의 변수에 접근할 수 없습니다.
* 재귀함수
    * 재귀는 자신을 호출하는 의미입니다. 즉 자기자신을 호출하는 함수입니다.
    * 재귀는 자신을 무한히 호출할 수 있으므로 while문처럼 탈출조건을 만들어주어야 합니다.
* 콜백함수
    * 특정이벤트가 발생했을때 시스템에 의해 호출되는 함수입니다.
    * 대표적으로는 핸들러처리가 있습니다.
    * 콜백함수는 주로 비동기식 처리모델에 사용됩니다.
---
### 타입검사
* typeof 변수 : 변수타입을 표시해줍니다.
* object.prototype.toString : 메소드의 객체를 나타내는 문자열을 반환합니다.
    * slice를 이용하여 메소드의 타입을 체크할 수 있습니다.
* instanceof : 피연산자인 객체가 오른쪽에 명시된 타입의 인스턴스 여부를 알려줍니다.
* isArray : isArray는 배열인지 아닌지를 구별하여줍니다;
```
var a = "hello"
type of a //strign

Object.prototype.toString.call(new String()); //[object String]

function Person(){}
const person = new Person();

console.log(person instanceof Person) //true
console.log(person instanceof Object) //true

var b =[1,2,3,]
console.log(b.isArray([])) //true
```
---
### this
* 함수는 호출되어질때 arguments 객체와 this를 암묵적으로 전달받습니다.
* this는 바인딩 되어진 객체는 한가지가 아니라 해당 함수호출 방식에 따라 this에 바인딩되는 객체가 달라집니다.
#### 함수호출방식과 this 바인딩
* this에 바인딩할 어떤 객체가 동적으로 결정되어집니다.
* 어떻게 호출되었는지에따라서 this에 바인딩할 객체가 동적으로 결정됩니다.
* 함수의 호출방식으로 4개가 있습니다
    1. 함수호출. 
    2. 메소드 호출.
    3. 생성자 함수 호출
    4. apply/call/bind 호출이 있습니다.
#### 함수 호출
* 전역객체는 모든객체의 최상위 객체를 의미합니다.
* browser-side에서는 window , server-side에서는 global객체를 의미합니다.
* 전역객체는 전역스코프를 갖는 전역변수를 프로퍼티로 소유합니다.
* 기본적으로 this는 전역객체에 바인딩 됩니다. 내부함수일 경우에도 this는 전역객체에 바인딩됩니다.
* 내부함수는 일반함수,메소드함수,콜백함수 어디에 선언되어도 this는 전역객체를 바인딩합니다.
#### 메소드 호출
* 메소드 내부의 this는 해당 메소드를 소유한 객체 즉 해당메소드를 호출한 객체에 바인딩 됩니다.
#### 생성자 함수 호출
* 자바스크립트의 생성자 함수는 말 그대로 객체 생성하는 역활을 합니다.
* new연산자를 붙여 호출하면 해당함수는 생성자 함수처럼 동작합니다.
    1. 빈 객체 생성 및 this바인딩
    2. this를 통한 프로퍼티 생성
    3. 생성된 객체 반환
* 객체리터럴 : 생성된 프로토타입 객체는 Object.prototype.
* 생성자함수 : 생성된 프로토타입 객체는 함수명.prototype.
* new연사자를 붙이지 않고 호출할 경우
    * 연산자를 붙이지 않더라도 생성자 함수로 동작합니다.
    * 객체 생성목적을 작성한 함수에 new를 붙이지 않거나. 일반함수에 new를 붙여 호출하면 오류가 발생할 수 있습니다.
---
### 실행 컨텍스트
* 실행가능한 코드를 형상화하고 구분하는 추상화적인 개념입니다.
    * 전역 코드 : 전역에 실행되는 코드
    * Eval 코드 : eval함수로 실행되는 코드
    * 함수 코드 : 함수내에 존재하는 코드
* 실행 컨텍스트를 물리적 객체의 형태로 관리합니다.
* 실행 컨텍스트의 3가지 객체.
#### Variable Object(V/O)
* 실행컨텍스트가 생성되면 실행에 필요한 정보들을 담은 객체를 생성하는것을 의미합니다.
* 전역 컨텍스트일 경우
    * (V/O)는 유일하고 최상위에 위치하게 됩니다.
    * 전역변수,전역함수 등을 포함하는 전역객체(global object)를 가리킵니다.
* 함수 컨텍스트일 경우
    * 인수들의 정보를 배열의 형태로 담고있는 객체인 arguments object를 생성합니다.
    * 활성객체(activation object)를 가리킵니다.
#### scope chain
* 전역 또는 함수가 참조할 수 있는 변수,함수 선언등의 정보를 담고있는 전역객체 또는 활성객체입니다.
* 스코프 체인은 식별자중, 객체의 프로퍼티가 아닌 변수를 검색하는 메커니즘입니다.
---
### 클로저
```
function closureFunction(){
    var a = 10
    var innerFunc = function() {console.log(a)}
    innerFunc()
}

closureFunction() //10
```
* 내부함수인 innerFunc는 외부함수인 closureFunction a값에 접근할수 있는것을 볼 수 있습니다.
* 순서를 생각하면 innerFunc의 스코프는 내부에 a값을 검사하였지만 존재하지 않았습니다.
* 외부의 closureFunction의 a값을 검색성공 하여서 출력이 되었습니다.
#### 클로저의 활용
* 현재 상태의 기억과 함께 변경된 최신상태를 유지합니다.
* 전역변수 사용을 억제할수 있습니다.
    * 전역변수는 누구나 접근할 수 있고 수정이 가능하기때문에 다른 함수에 의하여 값이 변경될 경우 화면에출력이 이상하게 될 수도 있습니다.
* 정보은닉이 가능해집니다.
---
### 빌트인 객체
#### 네이티브 객체
* ECMAScript 명세에 정의된 객체를 말하며 어플리케이션 전역 공통 기능을 제공합니다.
* 네이티브 객체를 global objects라고도 합니다.
#### object
* object() 생성자 함수는 객체를 생성합니다.
* 인수값에 따라 강제 형변환된 객체가 반환됩니다.
* 객체를 생성할 경우 특별한 상황이 아니면 객체리터럴 방식을 사용하는것이 일반적입니다.
#### function
* 자바스크립트 함수는 모든 객체들처럼 new연산자를 사용해 생성할 수 있습니다.
```
var func1 = new Function('a','b',return a+b)

func1(5,6) //11
```
#### Boolean
* 원시타입 boolean을 위한 래퍼 객체입니다.
#### Number
* number를 다룰때 유용한 프로퍼티와 메소드를 제공하는 래퍼객체입니다.
* Number객체는 Number() 를 이용해서 생성할 수 있습니다.
* Number()에 숫자가 아닌값이 들어가면 NaN을 반환합니다.
* new연산자를 붙이지 않으면 Number을 반호나하고 원시타입 숫자를 반환합니다.
* Number method : https://poiemaweb.com/js-number
#### math
* 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체입니다.
* 정적 프로퍼티와 메소드만 재공합니다.
* Math method : https://poiemaweb.com/js-math
#### String
* 문자열을 다룰때 사용되는 프로퍼티와 메소드를 제공하는 래퍼 객체입니다.
* 원시타입이 래퍼객체의 메소드를 사용할수 있는 이유는 ? 
    * 원시타입으로 프로퍼티나 메소드를 호출할 때 원시타입과 연관된 래퍼 객체로 일시적으로 변환되어 프로토타입 객체를 공유하기 때문입니다.
* String method : https://poiemaweb.com/js-string
#### Reg Exp
* 풀어 말하면 정규표현식입니다.
* 특정 내용을 찾거나 대체 또는 발췌하는 사용합니다.
* 반복문과 조건문을 사용하는 코드도 정규표현식을 사용하면 간편하게 사용할 수 있습니다.
* 정규표현식은 주석이나 공백을 허용하지 않고 여러가지 기호를 섞어 사용하여 인수인계,유지보수쪽에서 효율이 떨어질 수 있습니다
* Reg Exp method : https://poiemaweb.com/js-regexp
#### Array
* 배열은 여러개의 값을 순차적으로 저장할때 사용됩니다.
* Array method : https://poiemaweb.com/js-array
#### Error
* 에러 생성자는 에러 객체를 생성합니다.
* try..catch구문으로 에러가 발생되면 throw됩니다.
### 호스트객체
* window,XmlHttpRequest,HTMLElment등의 DOM노드 객체와 같이 호스트 환경에 정의된 객체를 말합니다.
### BOM 과 DOM
* BOM(Browser Object Model) : 브라우저창의 모델을 생성합니다. window객체를 최상위로 두고 현재 브라우저 창 또는 탭을 포현하는 객체입니다.
* DOM(Document Object Model) : 최상위 모델은 Document즉 모든 값들을 태그,속성 값을 표현합니다.
---
### DOM(Document Object Model)
* 웹문서를 브라우저에 렌더링 하기위하여 이해할수 있는 구조로 메모리에 올려야합니다.
* 웹문서를 로드한 후, 파싱하여 웹문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는것을 DOM이라고 합니다.
#### DOM tree
* DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미합니다.
* DOM tree는 4가지로 구성됩니다.
    * 문서노드 : 트리 최상위에 존재하며, 요소,어트리뷰트,텍스트노드에 접근하려면 문서노드를 통해야합니다.
    * 요소노드 : HTML요소를 표현합니다.
    * 어트리뷰트 노드 : HTML요소의 어트리뷰트를 표현합니다.
    * 텍스트 노드 : 텍스트노드는 요소의 노드 마지막이며 자식 노드를 가질 수 없습니다.
#### 요소 노드 선택.
* document.getElementById,document.querySelector 를 이용하여 자바스크립트에서 요소에 접근할 수 있습니다.
#### 여러 요소 접근
* document.getElementByClassName() class노드 모두를 접근할 수 있습니다.
* 반환값은 HTMLCollection입니다. 반환값이 복수인 경우 리스트를 담아 변환하기 위해 객체로 배열과 비슷한 사용법을 가집니다.
* document.getElementByTagName : 태그네임으로 모두를 선택합니다.
* document.querySelectorAll : CSS선택자를 사용하여 요소노드를 모두 선택합니다.
* parentNode,ChildNode를 이용하여 해당 부모노드,자식노드를 탐색할 수 있습니다.
#### 텍스트 노드에 접근/수정
* className : 해당 노드의 클래스 명을 알 수 있습니다
* classList : 해당노드의 리스트를 알 수 있습니다.
* id : 어트리뷰트의 값을 구하거나 수정이 가능합니다.
* hasAttriibute : 저장한 어트리뷰트를 가지고 있는지 검사합니다.
* getAttribute : 지정한 어트리뷰터 값을 획득합니다.
* setAttribute : 어트리뷰트와 값을 설정합니다.
* removeAttribute : 지정한 어트리뷰트를 제거합니다.
#### innerHTML vs DOM조작방식 vs insertAdjacentHTML()
* innerHTML
    * 장점
        1. DOM조작 방식에 비해 빠르고 간편합니다.
        2. 간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있습니다.
        3. 콘텐츠를 취득할 수 있습니다.
    * 단점
        1. XSS공격에 취약합니다.
        2. 해당요소의 내용을 덮어씁니다.
* DOM조작방식
    * 장점
        1. 특정 노드 한개를 DOM에 추가할때 적합니다.
    * 단점
        1. innerHTML 보다 느리고 코드가 복잡합니다.
* insertAdjacentHTML
    * 장점
        1. 간단한게 문자열로 정의도니 요소를 추가할 수 있습니다.
        2. 삽입 위치를 선정할 수 있습니다
    * 단점
        1. XSS공격에 취약합니다.
---
### REST API
* REST는 HTTP프로토콜을 의도에 맞게 디자인 하도록 유도하고 있습니다.
#### REST API중심 ㅠ칙
1. URI은 정보의 자원을 표현해야 합니다.
* 리소스 명은 동사보다 명사를 이용합니다. URI는 자원을 표현하는데 중점을 두어야 합니다.
2. 자원에 대한 행위는 CRUD등으로 표현합니다.
#### json-server
* GET : 리소스의 모든 데이터를 조회합니다.
* POST : 리소스의 새로운 데이터를 생성합니다.
* PUT : 리소스의 새로운 데이터를 생신합니다.
* PATCH : 리소스의 일부를 갱신할때 사용합니다
* DELETE : 리소스를 제거합니다.
---
### SPA
* 장점 
    * 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있습니다.
    * 한번 다운로드 한 후 페이지가 변경 요청하면 갱신에 필요한 데이터만을 전달받아 갱신하므로, 전체적인 트래픽을 감소할 수 있습니다.
* 단점
    * 초기 구동속도가 느립니다.
    * 검색엔진최적화가 어렵습니다.(SSR로 해결이 가능합니다.)
    * 보안 이슈가 있습니다.
#### 라우팅
* 출발지에서 목적지까지의 경로를 결정하는 기능입니다.
* 브라우저가 화면을 전환하는 경우는 URL입력,링크이동,뒤로가기,앞으로가기로 웹기록을 이용하는 방법이 있습니다.
#### SPA와 라우팅
* 서버 렌더링 : 서버로 html화면을 표시하는데 부족함이 없는 완전한 리소스를 클라이언트에 응답합니다.
* 자바스크립트가 필요없이 응답된 html만으로 렌더링이 가능하며 각페이지마다 고유의 URL이 존재하므로 히스토리 관리 및 SEO대응에 아무런 문제가 없습니다.
* 중복된 리소스마다 수신해야하며,전체페이지를 렌더링하는 과정에서 새로고침이 발생하여 사용성이 좋지못합니다.
#### AJAX방식
* 서버와 브라우저간의 데이터 교환을 할 수있는 통신방식을 의미합니다.
* URL이동이 없고 주소창의 주소가 변환하지 않습니다. 히스토리 관리가 동작되지 않고, 새로고침을 하면 주소창의 주소가 변경되지 않아 매번 첫 페이지가 다시 로딩이 됩니다. 또한 SEO이슈로부터 자유로울수 없습니다.
#### Hash방식
* 위의 문제를 해결하기 위해 나온것이 Hash방식입니다.
* 네이게이션이 클릭되어지면 hash가 추가된 URI가 주소창에 표시됩니다.
* URL이 동일한 상태에서 hash가 변경되면 브라우저는 서버에 어떠한 요청도 하지않습니다.
#### PJAX방식
* hash방식도 SEO이슈로부터 자유로울수 없습니다.
* pushState와 popState를 활용하여 진행합니다.

